C51 COMPILER V9.54   INTERFACING_LW1                                                       10/15/2018 16:33:26 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE INTERFACING_LW1
OBJECT MODULE PLACED IN .\Objects\interfacing_lw1.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.exe interfacing_lw1.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Li
                    -stings\interfacing_lw1.lst) TABS(2) OBJECT(.\Objects\interfacing_lw1.obj)

line level    source

   1          /**
   2           SPI HOMEWORK2 , LABWORK2 (SAME PROGRAM)
   3           */
   4          
   5          /* @section  I N C L U D E S */
   6          #include "at89c5131.h"
   7          #include "stdio.h"
   8          #define LCD_data  P2                // LCD Data port
   9          #define sample 1
  10          void SPI_Init();
  11          void LCD_Init();
  12          void Timer_Init();
  13          void LCD_DataWrite(char dat);
  14          void LCD_CmdWrite(char cmd);
  15          void LCD_StringWrite(char * str, unsigned char len);
  16          void LCD_Ready();
  17          void sdelay(int delay);
  18          void display_value();
  19          void display_voltage_lcd();
  20          void delay_ms(int delay);
  21          char int_to_string(int val);
  22          void sample_data(int no_of_samples);
  23          void binary_to_ascii(int binary);
  24          sbit CS_BAR = P3^4;                 // Chip Select for the ADC
  25          sbit FS = P3^5;                 // Frame Select for the ADC
  26          sbit LCD_rs = P0^0;                 // LCD Register Select
  27          sbit LCD_rw = P0^1;                 // LCD Read/Write
  28          sbit LCD_en = P0^2;                 // LCD Enable
  29          sbit LCD_busy = P2^7;               // LCD Busy Flag
  30          sbit LED = P1^7;
  31          sbit ONULL = P1^0;
  32          bit transmit_completed= 0;              // To check if spi data transmit is complete
  33          bit offset_null = 0;                // Check if offset nulling is enabled
  34          bit roundoff = 0;
  35          bit send_data= 0;             // To check if spi data transmit is complete
  36          bit going_up= 1;  
  37          
  38          unsigned int  voltage= 0;
  39          
  40          
  41          unsigned char serial_data;
  42          unsigned char data_high;
  43          unsigned char data_low;
  44          unsigned char data_msb=0;
  45          unsigned char data_lsb=0;
  46          unsigned char count=0, i=0;
  47          float fweight=0;
  48          int counter=0;
  49          char state=0;
  50          unsigned char voltage_display_ascii[4];
  51          
  52          /**
  53          
  54           * FUNCTION_INPUTS:  P1.5(MISO) serial input  
C51 COMPILER V9.54   INTERFACING_LW1                                                       10/15/2018 16:33:26 PAGE 2   

  55           * FUNCTION_OUTPUTS: P1.7(MOSI) serial output
  56           *                   P1.4(SSbar)
  57                               P1.6(SCK)
  58           */
  59           
  60          void main(void)
  61          {
  62   1        P3 = 0x00;
  63   1        CS_BAR = 1; 
  64   1        FS = 1;
  65   1      
  66   1        SPI_Init();
  67   1        Timer_Init();
  68   1        
  69   1        while(1)
  70   1        {
  71   2          if(send_data){
  72   3            
  73   3          CS_BAR = 0;                               // falling edge of CS bar
  74   3          FS = 0;
  75   3          
  76   3          data_lsb = voltage;
  77   3          data_msb = voltage>>8;
  78   3          SPDAT= data_msb;                      // first 4 bits will be address of the channel. next 4 can be anything
  79   3          while(!transmit_completed);               // wait for the transmit complete flag  
  80   3          transmit_completed = 0;                   // make the flag 0
  81   3          
  82   3          SPDAT =data_lsb;                      // here can send anything. doesnt matter. it will not read the address till t
             -he next cycle starts. or eoc becomes low and high again.
  83   3                                            //this we are sending because we are receiving 8 bits, so have to send something. 
  84   3          while(!transmit_completed); 
  85   3          transmit_completed = 0; 
  86   3          FS = 1;
  87   3          CS_BAR = 1;    
  88   3          send_data=0;
  89   3          }
  90   2        }
  91   1      
  92   1      }
  93          send_SPI (char transmit_data){
  94   1      
  95   1        SPDAT = transmit_data;
  96   1          while(!transmit_completed);               // wait for the transmit complete flag  
  97   1          //data_save_high = serial_data;               // save the 
  98   1          transmit_completed = 0;                   // make the flag 0
  99   1          SPDAT =0x00;                      // here can send anything. doesnt matter. it will not read the address till the n
             -ext cycle starts. or eoc becomes low and high again.
 100   1          
 101   1                                      //this we are sending because we are receiving 8 bits, so have to send something. 
 102   1          while(!transmit_completed); 
 103   1      //    data_save_low = serial_data;
 104   1          transmit_completed = 0; 
 105   1      
 106   1        return;
 107   1      }
 108          /**
 109           * FUNCTION_PURPOSE:interrupt
 110           * FUNCTION_INPUTS: void
 111           * FUNCTION_OUTPUTS: transmit_complete is software transfert flag
 112           */
 113          void it_SPI(void) interrupt 9 /* interrupt address is 0x004B, (Address -3)/8 = interrupt no.*/
 114          {
C51 COMPILER V9.54   INTERFACING_LW1                                                       10/15/2018 16:33:26 PAGE 3   

 115   1        switch  ( SPSTA )         /* read and clear spi status register */
 116   1        {
 117   2          case 0x80:  
 118   2            serial_data=SPDAT;   /* read receive data */
 119   2            transmit_completed=1;/* set software flag */
 120   2          break;
 121   2      
 122   2          case 0x10:
 123   2            
 124   2          break;
 125   2        
 126   2          case 0x40:
 127   2          break;
 128   2        }
 129   1      }
 130          
 131          void timer0_ISR (void) interrupt 1
 132          {
 133   1            TR0 = 0;
 134   1          
 135   1          TH0 |= 0xF4;   //for  6/2^12
 136   1          TL0 |= 0x8E;  // for  6/2^12
 137   1          send_data = 1;
 138   1          TR0 =1;
 139   1        
 140   1        if (going_up)
 141   1        {
 142   2          if (voltage<4095){
 143   3            voltage++;
 144   3          }
 145   2            else {
 146   3          
 147   3          going_up=0;
 148   3        }
 149   2        }
 150   1        else {
 151   2            if (voltage>0){
 152   3            voltage--;
 153   3          }
 154   2            else {
 155   3          
 156   3          going_up=1;
 157   3        }
 158   2        
 159   2        }
 160   1        
 161   1      
 162   1      
 163   1        return;
 164   1      
 165   1      }
 166          
 167          
 168          /**
 169          
 170           * FUNCTION_INPUTS:  P1.5(MISO) serial input  
 171           * FUNCTION_OUTPUTS: P1.7(MOSI) serial output
 172           *                   P1.4(SSbar)
 173                               P1.6(SCK)
 174           */ 
 175          void SPI_Init()
 176          {
C51 COMPILER V9.54   INTERFACING_LW1                                                       10/15/2018 16:33:26 PAGE 4   

 177   1        CS_BAR = 1;                     // DISABLE ADC SLAVE SELECT-CS 
 178   1        SPCON |= 0x20;                  // P1.1(SSBAR) is available as standard I/O pin 
 179   1        SPCON |= 0x01;                  // Fclk Periph/4 AND Fclk Periph=12MHz ,HENCE SCK IE. BAUD RATE=3000KHz 
 180   1        SPCON |= 0x10;                  // Master mode 
 181   1        SPCON |= 0x08;                // CPOL=1; transmit mode example|| SCK is 0 at idle state
 182   1        SPCON &= ~0x04;                 // CPHA=0; transmit mode example 
 183   1        IEN1 |= 0x04;                   // enable spi interrupt 
 184   1        EA=1;                           // enable interrupts 
 185   1        SPCON |= 0x40;                  // run spi;ENABLE SPI INTERFACE SPEN= 1 
 186   1      
 187   1      //  IPH0 |=0x10;
 188   1      //  IPL0 |=0x10;
 189   1      }
 190          
 191          void Timer_Init()
 192          {
 193   1        // Set Timer0 to work in up counting 16 bit mode. Counts upto 
 194   1        // 65536 depending upon the values of TH0 and TL0
 195   1        // The timer counts 65536 processor cycles. A processor cycle is 
 196   1        // 12 clocks. FOr 24 MHz, it takes 65536/2 uS to overflow
 197   1          
 198   1          TH0 |= 0xF4;   //for  5000
 199   1          TL0 |= 0x8E;  // for 5000
 200   1          
 201   1          TMOD|=0X01;
 202   1          EA=1;
 203   1          ET0=1;
 204   1          TR0=1;
 205   1          
 206   1        //Initialize TH0
 207   1        //Initialize TL0
 208   1        //Configure TMOD 
 209   1        //Set ET0
 210   1        //Set TR0
 211   1      }
 212          /**
 213           * FUNCTION_PURPOSE:LCD Initialization
 214           * FUNCTION_INPUTS: void
 215           * FUNCTION_OUTPUTS: none
 216           */
 217          
 218          /**
 219           * FUNCTION_PURPOSE: A delay of 15us for a 24 MHz crystal
 220           * FUNCTION_INPUTS: void
 221           * FUNCTION_OUTPUTS: none
 222           */
 223          void sdelay(int delay)
 224          {
 225   1        char d=0;
 226   1        while(delay>0)
 227   1        {
 228   2          for(d=0;d<5;d++);
 229   2          delay--;
 230   2        }
 231   1      }
 232          
 233          /**
 234           * FUNCTION_PURPOSE: A delay of around 1000us for a 24MHz crystel
 235           * FUNCTION_INPUTS: void
 236           * FUNCTION_OUTPUTS: none
 237           */
 238          void delay_ms(int delay)
C51 COMPILER V9.54   INTERFACING_LW1                                                       10/15/2018 16:33:26 PAGE 5   

 239          {
 240   1        int d=0;
 241   1        while(delay>0)
 242   1        {
 243   2          for(d=0;d<382;d++);
 244   2          delay--;
 245   2        }
 246   1      }
*** WARNING C290 IN LINE 107 OF interfacing_lw1.c: missing return value


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    267    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     20    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      5    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
